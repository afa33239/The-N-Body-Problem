SYSTEMSTATE DESIGN

SystemState is immutable: integrators create a new SystemState each step.

SystemState stores only a list of Body objects (the universe at one moment).

SystemState should not contain physics or simulation logic.

Copying:
- Integrators do not copy states; they build new ones.
- We may add deep/shallow copy options later if needed.

SystemState is pure data, no side effects.




PHYSICS PARAMETERS (SOFTENING)

Softening prevents huge forces when bodies get extremely close (denominator becomes extremely small when close).

Add parameter 'softening' to SimulationConfig.

Softening is used only in physics calculations and solvers.

Formula:
Use (r^2 + softening^2) instead of r^2 in gravity.

Integrators do not use softening directly.
SimulationConfig stores it because it is a simulation setting.



VECTOR REPRESENTATION DECISION

We will store positions and velocities as simple attributes:
x, y, z and vx, vy, vz.

Reason:
- simplest to read and maintain
- works well for Barnes–Hut and adaptive timestep
- does not force early NumPy/Numba dependencies
- allows future vectorized solvers without touching Body class

This will be extended when the project enters 3D.




ENGINE READY CHECK

Simulation handles time loop, integrator, solver, and state.
Integrator updates state but never computes forces.
Solver computes forces but never updates state.
Physics only defines formulas.
SystemState stores only bodies (immutable per step).
Config stores only parameters, not runtime objects.

This design supports:
- Barnes–Hut
- 3D upgrade
- Adaptive timestep
- Energy tracking
- Vectorized and Numba solvers

Architecture is ready for Phase 2 and beyond.